// This is used to test the performance of the federated runtime in decentralized mode
// (number of reactions per second).
// In this test, the Source reactor sends a large number of messages one
// microstep apart (so that there is no waiting for physical time to elapse,
// which would distort the statistics).
target C {
  coordination: decentralized,
  timeout: 1 sec
}

reactor Source(num_messages: int = 10) {
  output y: int
  logical action a
  state count: int = 0

  reaction(startup, a) -> y {=
    (self->count)++;
    if (self->count < self->num_messages) {
        tag_t tag = lf_tag();
        lf_print("Source sending %d at tag " PRINTF_TAG,
            self->count,
            tag.time - lf_time_start(), tag.microstep
        );
        lf_set(y, self->count);
        lf_schedule(a, 0);
    }
  =}
}

reactor Destination(num_messages: int = 10) {
  input x: int
  state s: int = 1

  reaction(x) {=
    lf_print("Destination received: %d", x->value);
    if (x->value != self->s) {
        lf_print_error_and_exit("Expected %d and got %d.", self->s, x->value);
    }
    self->s++;
  =}

  reaction(shutdown) {=
    lf_print("**** shutdown reaction invoked.");
    if (self->s != self->num_messages) {
        lf_print_error_and_exit("Expected %d but got %d.", self->num_messages, self->s);
    }
    lf_print("Approximate time per reaction: " PRINTF_TIME " ns", lf_time_physical_elapsed()/(self->s+1));
  =}
}

federated reactor(period: time = 1 usec) {
  c = new Source()
  d = new Destination()
  c.y -> d.x after 1 usec
}
